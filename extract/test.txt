   # PAT刷题记录from杨硕。 （前放留出空格）

#### luanlai
## 1001 A+B Format

第一个题**取余**的思路写的，只有一个点要注意：

+ 逗号后面的数整除之后记得**补零**！

  ```c++
  cout << setw(3) << setfill('0') << input;
  ```

#### Max Subsequence Sum

做完题之后想了想觉得还是有必要实# 尝试一下bug 现一下数据结构最基础的代码，仅仅是想用C++练练手而已。参考MOOC陈越姥姥的数据结构课程，把以下内容进行了实现:

+ ##???最大序列和的四种算法（**分治法**、**在线处理**）

  + **分治法**穿参数时**保持同一个数组**，参数传入子序列**开头和结尾位置的整形变量**就行了，如果每次都创建新的子序列数组程序会不报错但是没结果，另外还要注意计算跨边界的子序列和时要**分开处理**再相加：

    ```c++
    int mid_sum_left = 0;
    int mid_sum_left_max = 0;
    int mid_sum_right = 0;
    int mid_sum_right_max = 0;

    for(int i = mid; i >= left; i--){
        mid_sum_left += nums[i];
        if(mid_sum_left > mid_sum_left_max) mid_sum_left_max = mid_sum_left;
    }
    for(int i = mid + 1; i <= right; i++){
        mid_sum_right += nums[i];
        if(mid_sum_right > mid_sum_right_max) mid_sum_right_max = mid_sum_right;
    }

    int max_mid = mid_sum_left_max + mid_sum_right_max;
    ```



  + **在线处理**的话两个判断条件（sum小于0，sum大于max_sum）交换顺序对算法正确性没有影响。

  + 最后贴上运行时间图，四者的性能可见一斑。

    ![TIM图片20200115130650](D:\A_I love study\PAT_Prepare\pic\TIM图片20200115130650.png)



#### 线性表的顺序存储实现

  + 顺序表的实现用来帮我熟悉了一遍C++的类和模板的用法，实现时的问题有：
    + 增和删记得length的加减
    + 传入的参数i对应真实位置编号，函数处理时的下标是i-1，要做到统一

  + 链表的实现

    + 插入和删除与顺序表相比变得简单了很多，但是长度需要遍历整个链表，并且类中不直接保存长度属性。
    + 析构函数需要自己delete掉创建的所有Node节点。




## 1002 A+B for Polynomials

学完链表之后顺势就可以做这个陈越姥姥出的题，不过简单点的话不用实现链表类，创建一个结构体就行，这个题的条件给的贼合理，输入是按照指数的大小从大到小输入的，用链表做起来思路格外清楚，而且1000的次数限制和10的项数限制下，采用链表很节约空间。坑在于输出的格式，**系数一定要保留一位小数并且不等于零！**除此之外真的没有其他问题了。附上**C++浮点数输出格式**的限制方法备忘。

```c++

## test test test
cout << setiosflags(ios::fixed) << setprecision(1) << now->co;//保留一位小数的写法
cout << setprecision(2) << now->co;//保留2位有效位的写法
```

然后1003直接给我整了个最短路径问题，由于才开始看数据结构的网课，我决定挑着做学过的内容对应的题。

## 1007 Maximum Subsequence Sum

这个题一开始觉得在线处理就能做，琢磨了半天得到的思路是：通过判断max_sum前后是否有变化得到一个最大子序列末尾的位置，判断的条件写成sum>max_sum的话得到的是最前面的那个最小子序列。举个例子，对于 ***-10， 1， 2， 3， 4， -5， -23， 3， 7， -21*** 这个序列，可以得到 ***4*** 的位置4（数组中的标号），然后前面那个***1*** 的位置怎么得到就很难搞了。

后来我变通了一下，把序列倒了个顺序，再把条件变成sum>=max_sum，就能得到标号最大的最小子序列的末尾位置，这样反过来不就是标号最小的最小子序列开头的位置了吗。

到了这里，代码只剩一个例子跑不过去了，由于想的时间太久我决定看看其他人的答案，发现了一种很极端的情况，题目要求全为负数时才返回0和开头结尾的数字，但是**有这么一种情况：序列中包含负数和零**。这种情况下仍然要找出标号最小的零序列，所以我的max_sum一开始不能设置为0，要设置为-1，这样得到看到0的时候才会有变化。不得不说，是真的坑！

接下来我想研究一下别人怎么一个循环就写出来的，我的思路虽然巧妙，但是总感觉有些不直观，太绕了。我找到了这样一个答案：

```c++
#include<bits/stdc++.h>
using namespace std;
int a[10001];
int main(void)
{
	int n,i;
	scanf("%d",&n);
	for(i=0;i<n;i++) scanf("%d",&a[i]);
	int tmp=0,res=-1,le=0,ri=n-1,p=0; //这个-1的灵感就是从这儿来的
	for(i=0;i<n;i++)
	{
		tmp+=a[i];
		if(tmp<0)
		{
			tmp=0;
			p=i+1;//和在线处理的判断类似
		}
		else if(tmp>res)
		{
			res=tmp;
			le=p;//实际上可能会重复把p赋给le
			ri=i;//看到这里我差不多悟了，左边的位置在第一个判断（tmp < 0）里面增加就行了！
		}
	}
	if(res<0) res=0;
	printf("%d %d %d",res,a[le],a[ri]);
	return 0;
}
```

看完这个代码，我才恍然大悟，可以用一个临时变量把左边位置先存着，在sum<0成立的时候，让tmp_le = i + 1,即随时有可能下一个位置就开始满足sum>0了。同时让le和ri保持同步地更新以维持一个最小子序列，因为每次le和ri的赋值都是在sum>max_sum时发生的。

以上，就是今日做题的全部记录，明天继续！

#### 堆栈（Stack）

前/中/后缀表达式

##### 多的一个